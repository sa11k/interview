### 1. 자기소개

```markdown
개인 기록..
```

### 2. 지원동기

```markdown
개인 기록..
```

### 3. 포트폴리오 관련 질문
```markdown
개인 기록..
```

### 4. CS 질문 (⭐️ 표시는 한 번 이상 기술 면접에서 질문 받은 내용)

- 예상질문 블로그
    
    [백엔드 신입 면접질문 공부(자바 Java)](https://cano721.tistory.com/m/131)
    
    [백엔드 신입 면접질문 공부(스프링 Spring & JPA)](https://cano721.tistory.com/m/185)
    
    [백엔드 신입 면접질문 공부 (디비 DB)](https://cano721.tistory.com/m/187)
    
    [백엔드 면접질문 공부 (네트워크 Network)](https://cano721.tistory.com/m/188)
    
    [백엔드 면접질문 공부(운영체제 OS)](https://cano721.tistory.com/m/189)
    
- 객체지향 프로그래밍
    - 객체지향 프로그래밍(OOP)이란?
        
        ```markdown
        객체들의 유기적인 협력과 결합으로 파악하고자하는 프로그래밍의 패러다임
        ```
        
    - 객체지향 프로그래밍의 장점
        
        ```markdown
        - 프로그램을 보다 유연하고 변경 용이하게 만들 수 있음
        - 코드 변경을 최소화하고 유지보수 하는데 유리
        - 코드의 재사용을 통해 반복적인 코드를 최소화하고 코드를 최대한 간결하게 표현할 수 있음
        ```
        
    - 객체란?
        
        ```markdown
        모든 실재하는 대상
        우리가 보고 느끼고 인지할 수 있는 그 모든 것
        
        속성(state)과 기능(behavior)로 분류
        ```
        
    - 객체지향의 4대 특징 ⭐️
        
        ```markdown
        1. 추상화 : 객체의 공통적인 속성과 기능을 추출하여 정의하는 것
        2. 상속 : 기존의 클래스를 재활용하여 새로운 클래스를 작성
        3. 캡슐화 : 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것
        4. 다형성 : 어떤 객체의 속성이나 기능이 상황에 따라 여러가지 형태를 가질 수 있는 성질
        ```
        
    - 객체지향 5대 원칙(SOLID) ⭐️
        
        ```markdown
        1. 단일 책임 원칙 : 모든 클래스는 각각 하나의 책임만 가져야 한다.
        2. 개방 폐쇄 원칙 : 확장에는 열려있으나, 변경에는 닫혀있어야 한다.
        3. 리스코프 치환 원칙 : 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다.
        4. 인터페이스 분리 원칙 : 하나의 범용적인 인터페이스보다 여러개의 구체적인 인터페이스로 분리하는 것이 좋다.
        5. 의존 관계 역전 원칙 : 프로그래머는 추상화에 의존해야지 구체화에 의존해선 안된다.
        ```
        
    - 객체와 클래스의 차이
        
        ```markdown
        클래스는 객체를 만드는 설계도
        ```
        
- MSA(Micro Service Architecture) ⭐️
    ```markdown
    - 장점
        - 서비스가 도메인별로 찢어져있기 때문에, 장애가 한 곳에 나면 다른 곳에 영향을 미치지 않음
    - 단점
        - 너무 resource가 많이 들음
    ```
    
- Java
    - 추상 클래스와 인터페이스의 차이
        
        ```markdown
        추상 클래스와 인터페이스는 상속 받는 클래스 혹은 구현하는 인터페이스 안에 있는 추상 메소드를 구현하도록 강제한다.
        
        추상 클래스는 그 추상 클래스를 상속받아서 기능을 이용하고, 확장시키는 것이 목적
        인터페이스는 함수의 껍데기만 있는데, 그 함수의 구현을 강제하기 위해 존재
        ```
        
    - 클래스 변수(Static 멤버)와 인스턴스 변수(Non-static 멤버)의 차이
        
        ```markdown
        클래스 변수는 클래스가 메모리에 올라갈 때 생성되며, 모든 인스턴스가 공유
        인스턴스 변수는 인스턴스가 생성될 때 생성되며, 각각의 인스턴스가 독립적인 인스턴스 변수를 가짐
        ```
        
    - 동일성 동등성 차이
        ```markdown
        동등성 : equals
        
        동일성 : ==
        
        - 두 객체를 비교할 때, equals만 override 해야할까?
            - 두 개 다 하는게 맞음
            - Hashmap이 결국에는 hash method를 통해서 return 되는 값을 주는 것
        ```
        
    - Error VS. Exception
        
        ```markdown
        Error : 프로그램 코드로 수습할 수 없는 심각한 오류
        Exception : 프로그램 코드로 수습이 가능한 다소 미약한 오류
        ```
        
    - checked Exception VS. Unchecked Exception
        
        ```markdown
        Checked Exception
        - RuntimeException의 하위 클래스가 아니면서 Exception 클래스의 하위 클래스
        - 반드시 에러 처리를 해야 함
        - 컴파일 단계에서 확인
        - FileNotFoundException
        - ClassNotFoundException
        
        Unchecked Exception
        - RuntimeException의 하위 클래스
        - 명시적인 에러 처리를 강제하지 않음
        - runtime 중 발생할 수 있는 예외
        - ArrayIndexOutOfBoundsException
        - NullPointerException
        ```
        
    - overloading VS. overriding
        
        ```markdown
        overloading
        - 메서드 이름은 같고 매개변수의 갯수나 타입이 다른 함수 정의
        - 리턴값만을 다르게 갖는 오버로딩은 작성할 수 없음
        - 기존에 없던 새로운 매서드 정의
        
        overriding
        - 상위 클래스의 메서드를 하위 클래스가 재정의 하는 것
        - 매서드의 이름, 파라미터의 개수, 타입 동일해야하며 주로 상위 클래스의 동작을 상속받은 사위 클래스에서 변경하기 위해 사용
        - 상속 받은 매서드의 내용만 변경
        ```
        
    - 데이터 타입
        - 기본형 VS. 참조형
            
            ```markdown
            기본형 : 계산을 위해 실제 값을 저장
            참조형 : 객체의 주소를 저장. 기본형을 제외한 모든 것
            ```
            
    - 얕은 복사 VS. 깊은 복사
        
        ```markdown
        얕은복사
        - 원본을 참조하는 형식
        - 불변의 요소는 가져오고 가변의 요소는 같은 주소를 가리키게 됨
        
        깊은 복사
        - 새로운 객체를 만들고 내용도 새로 생성해서 복사
        - 복사된 객체는 원본 객체와 무관한 객체
        ```
        
- Spring/Spring Boot
    - Spring이란?
        
        ```markdown
        엔터프라이즈용 Java 애플리케이션 개발을 편하게 할 수 있게 해주는 오픈소스 경량급 애플리케이션 프레임워크
        
        - 프레임워크 : 어떠한 목적을 쉽게 달성할 수 있도록 해당 목적과 관련된 코드의 뼈대를 미리 만들어둔 것
        ```
        
    - Spring Boot란?
        
        ```markdown
        스프링으로 애플리케이션을 만들 때 필요한 설정을 간편하게 처리해주는 별도의 프레임워크
        자체적인 웹 서버를 내장하고 있음
        ```
        
    - Spring의 특징
        - POJO 프로그래밍 지향
            
            ```markdown
            POJO(Plain Old Java Object)란?
            - 순수 Java만을 통해서 생성한 객체
            - 다른 기술을 사용하지 않는 순수한 Java만을 사용하여 만든 객체
            - 외부 기술이나 규약의 변화에 얽매이지 않아, 보다 유연하게 변화와 확장에 대처할 수 있음
            ```
            
        - DI란? ⭐️
            
            ```markdown
            Dependency Injection
            - 스프링이 다른 프레임워크와 차별화되어 제공하는 의존 관계 주입 기능
            - 객체를 직접 생성하는 것이 아니라 외부에서 생성한 후 주입 시켜주는 방식
            - 모듈간 결합도가 낮아지고, 유연성이 높아짐
            - 외부(IoC 컨테이너)에서 생성된 객체를 주입시켜 setter 혹은 생성자, @Autowired 를 통해 사용
            ```
            
        - IoC란? ⭐️
            
            ```markdown
            Inversion of Control
            - 메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라, 외부에서 결정
            - 의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드를 작성할 수 있게 하여 가독성 및 코드 중복, 유지보수를 편하게 함
            - 프로그램의 진행 흐름과 구체적인 구현을 분리시킬 수 있음
            - 개발자는 비지니스 로직에 집중할 수 있음
            ```
            
        - AOP란?
            
            ```markdown
            관점 지향 프로그래밍으로 공통 관심 사항을 뽑아서 Aspect로 모듈화하여 재사용하는 것
            시스템 서비스에서 비즈니스 로직 분리
            ```
            
    - DTO, VO, DAO, Entity
        
        ```markdown
        DTO(Data Transfer Object)
        - 순수하게 데이터를 담아 계층 간으로 전달하는 객체
        - 로직을 갖고 있지 않은 순수한 데이터 객체
        
        VO(Value Object)
        - 값 그 자체를 나타내는 객체
        - 로직을 포함할 수 있음
        
        DAO(Data Access Object)
        - 데이터베이스의 data에 접근하기 위한 객체
        
        Entity
        - 실제 DB의 테이블과 매핑되는 객체
        ```
        
    - @SpringBootApplication이란?
        
        ```markdown
        이 어노테이션으로 인해 스프링 부트의 Bean을 읽어와 자동으로 등록해줌
        이 어노테이션이 있는 위치부터 설정을 읽어가기 때문에 항상 프로젝트의 최상단에 위치해야 함
        ```
        
    - Bean이란?
        
        ```markdown
        스프링 IoC 컨테이너가 관리하는 객체들
        @Component 어노테이션을 통해 개발자가 직접 작성한 class를 빈으로 등록할 수 있다.
        ```
        
    - BeanFactory와 ApplicationContext의 차이점
        
        ```markdown
        BeanFactory는 Bean을 제공하고 관리하는 기본적인 IoC 컨테이너 인터페이스
        ApplicationContext는 BeanFactory의 확장 버전으로 애플리케이션에 대한 모든 정보, 메타 데이터도 가지고 있음
        ```
        
    - 스프링 컨테이너의 생명주기
        
        ```markdown
        ApplicationContext 구현 클래스를 이용한 스프링 컨테이너 초기화(생성), getBean()을 이용한 Bean 객체 이용, close()를 이용한 스프링 컨테이너 종료
        ```
        
    - Spring Annotation
        
        ```markdown
        코드 사이에 주석처럼 쓰이며, 특별한 의미, 기능을 수행하도록 하는 기술
        프로그램에게 추가적인 정보를 제공해주는 메타데이터
        ```
        
        - @Controller, @Service, @Repository의 차이점
            
            ```markdown
            서버에서 처리 과정을 역할별로 분리해둔 것
            
            @Controller : 클라이언트의 요청을 받고 view를 반환
            @Service : 비즈니스 로직 처리
            @Repository : DB관리 및 DB CRUD 작업 처리
            ```
            
    - Spring MVC
        
        ```markdown
        MVC : Model-View-Controller
        
        Modle : 데이터 담당
        View : 사용자에게 보여지는 화면 담당
        Controller : 모델과 뷰를 연결시켜주는 역할 담당
        ```
        
        - MVC 패턴의 실행 흐름
            
            ```markdown
            1. 디스패처 서블렛이 클라이언트로부터 요청 받음
            2. 핸들러매핑에 해당하는 핸들러가 있는지 확인
            3. 해당하는 핸들러가 있으면 핸들러 이름을 디스패처 서블릿에 알려줌. 이때, 핸들러를 실행하기 전/후 처리할 것들을 인터셉터로 만들어줌
            4. 디스패처 서블릿은 해당 핸들러에게 제어권을 넘겨줌. 핸들러는 응답에 필요한 서비스를 호출하고 응답에 들어갈 뷰 이름을 디스패처 서블릿에게 알려줌
            5. 디스패처 서블릿은 뷰 이름과 모델을 뷰 리졸버에게 전달
            6. 뷰 리졸버는 해당하는 뷰를 만들어서 디스패처 서블릿에 전달
            7. 디스패처 서블릿은 해당하는 뷰를 클라이언트에 응답
            ```
            
        - MVC1 / MVC2
            
            ```markdown
            MVC1
            - 클라이언트 요청을 jsp 페이지가 받아서 처리
            - jsp가 컨트롤러와 뷰의 역할을 둘 다 함
            - jsp 페이지 내에는 비즈니스 처리를 위한 코드, 브라우저 결과를 보여주기 위한 출력 관리 코드가 섞여 있었음
            
            MVC2
            - 클라이언트 요청을 서블릿이 받음
            - 서블릿이 해당하는 요청에 알맞게 처리 후 jsp에게 결과 전달
            - 서블릿이 컨트롤러 역할, jsp가 뷰 역할을 나눠서 담당
            ```
            
    - Dispatcher Servlet
        
        ```markdown
        HTTP 프로토콜로 들어오는 요청을 가장 먼저 받아서 적합한 컨트롤러에게 전달하는 프론트 컨트롤러
        ```
        
        - Servlet
            
            ```markdown
            자바를 기반으로 하는 동적인 웹페이지를 만들어줄 수 있는 프로그래밍 기술
            서블릿을 통해 요청과 응답의 흐름을 메서드 호출만으로 체계적으로 다룰 수 있게 해 줌
            ```
            
    - Spring Security
        
        ```markdown
        스프링 기반의 애플리케이션의 보안을 담당하는 스프링 하위 프레임워크
        인증(Authenticate, 누구인지)과 인가(Authorize, 어떤 것을 할 수 있는지)를 담당하는 프레임 워크
        ```
        
    - @Controller와 @RestController의 차이
        
        ```markdown
        @Controller는 주로 View를 반환하기 위해 사용
        뷰리졸버를 통해 View를 찾아 렌더링
        데이터를 반환하고 싶으면 @ResponseBody 어노테이션을 활용하여 Json 형태로 데이터를 반환
        
        @RestController는 2개의 어노테이션을 합친것으로 Json 형태로 객체 데이터 바
        ```
        
- MySQL, Oracle 등의 RDBMS
    - 데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하는가?
        
        ```markdown
        무결성과 정합성이 중요하다고 생각합니다. 데이터의 값이 정확해야하며, 서로 일치해야합니다.
        
        - 예시
        주문 정보 테이블과 고객 정보 테이블에서 고객번호가 모두 -1로 입력되어 있다면, 정합성은 지켜졌다고 할 수 있습니다. 하지만, 고객 번호가 반드시 1 이상의 값을 가져야 한다면 이는 무결성이 훼손된 것입니다.
        또, 주문 정보 테이블에서 고객번호를 -1에서 2로 변경하였으나, 고객 정보 테이블에서 고객번호가 변경되지 않았다면, 정합성이 훼손된 것입니다.
        ```
        
    - Oracle과 MySQL의 차이
        
        ```markdown
        - Oracle
        대규모 트랜잭션 로드를 처리하고, 성능 최적화를 위해 여러 서버에 대용량 DB를 분산함
        
        - MySQL
        단일 데이터베이스로 제한되어있고, 대용량 데이터베이스로는 부적합. 작은 프로젝트에서 적용시키기 용이하며 이전 상태를 복원하는데 commit과 rollback만 존재
        ```
        
    - DB에서 index(색인)이란?
        
        ```markdown
        - DBMS에서 저장 성능을 희생하여 데이터 읽기 속도를 높이는 기능
        - 데이터가 정렬되어 들어감
        - 양이 많은 테이블에서 일부 데이터만 불러왔을 때, 이를 풀 스캔 시 처리 성능이 떨어짐
        ```
        
    - RDBMS
        
        ```markdown
        - 관계형 데이터베이스 관리 시스템
        - 관계형 모델을 기반으로 하는 DBMS
        - 테이블끼리 서로 연관되어 있어 일반 DBMS보다 효율적으로 데이터를 저장, 구성 및 관리 가능
        ```
        
- Rest API
    - Rest 정의
        
        ```markdown
        - Representational State Transfer
        - 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미
        ```
        
    - Rest 구성
        
        ```markdown
        - 자원(Resource) - URI
        - 행위(Verb) - HTTP METHOD
        - 표현(Representations)
        ```
        
- 프레임워크와 라이브러리의 차이
    
    ```markdown
    라이브러리를 사용하는 애플리케이션은 애플리케이션의 제어 흐름을 라이브러리에 내주지 않는다. 단지 필요한 시점에 라이브러리에 작성된 객체를 적재적소에 가져다 쓸 뿐이다.
    하지만, 프레임워크를 사용한 애플리케이션의 경우, 애플리케이션 코드에 작성한 객체들을 프레임워크가 필요한 시점에 가져다가 프로그램을 구동하기 때문에 프로그램의 제어권이 프레임워크로 역전된다.
    ```
    
- OSI 7계층
    
    ```markdown
    7계층(애플리케이션 계층) : 응용 프로세스와 직접 관계하여 일반적인 응용 서비스 수행
    6계층(표현 계층) : 코드 간의 번역을 담당
    5계층(세션 계층) : 데이터가 통신하기 위한 논리적인 연결
    4계층(전송 계층) : 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송. 보통 TCP 프로토콜 이용
    3계층(네트워크 계층) : 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능
    2계층(데이터링크 계층) : 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행
    1계층(물리 계층) : 전기적, 기계적, 기능적인 특성을 이용해 통신 케이블로 데이터 전송
    ```
    
- 프로세스와 스레드
    
    ```markdown
    - 프로세스 : 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램. 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
    
    - 스레드 : 프로세스 내에서 실행되는 여러 흐름의 단위
    ```
    
- 트랜잭션 ⭐️
    - 정의 ⭐️
        
        ```markdown
        데이터베이스의 상태를 변화시키기 위해 수행되는 작업의 단위
        ```
        
    - 특징 ⭐️
        
        ```markdown
        원자성 : 트랜잭션은 DB에 반영되거나, 반영되지 않아야 함
        일관성 : 트랜잭션의 결과는 언제나 일관성 있어야 함
        격리성 : 둘 이상의 트랜잭션이 동시에 일어날 때, 서로에게 영향을 미치지 않아야 함
        영원성 : 트랜잭션이 성공적으로 적용되었다면, 영원히 반영되어야 함
        ```
        
    - 격리수준 ⭐️
        
        [https://steady-coding.tistory.com/562](https://steady-coding.tistory.com/562)
        
        ```markdown
        - 0 : Read Uncommitted
        트랜잭션이 처리 중이거나, 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 조회 가능
        
        - 1: Read Committed
        트랜잭션의 변경 내용이 commit 되어야 다른 트랜잭션에서 조회 가능
        
        - 2 : Repetable Read
        트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회 가능
        
        - 3 : Serializable
        가장 단순하고 가장 엄격한 격리 수준. select 작업에서도 공유 잠금을 설정하게 되어 다른 트랜잭션에서 건드리지 못함.
        ```
        
- URL과 URI의 차이
    
    ```markdown
    URI(Uniform Resource Identifier)
    - 특정 리소스를 식별하는 통합 자원 식별자
    
    URL
    - 흔히 웹 주소라고도 하며, 컴퓨터 네트워크 상에서 리소스가 어디 있는지 알려주기 위한 규약 
    
    URI는 식별하고, URL은 위치를 가르킨다.
    ```
    
- ORM
    
    ```markdown
    Object Relational Mapping (객체-관계 매핑)
    - 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것
    - 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다는 이점이 있음
    - 재사용 및 유지보수의 편리성이 증가
    - DBMS에 대한 종속성이 줄어듬
    ```
    
    - JPA ⭐️
        - JPA 정의
            
            ```markdown
            자바 ORM 기술에 대한 API 표준 명세로, 객체와 데이터베이스 간의 관계를 편리하게 이어주는 것
            ```
            
        - 영속성 컨텍스트
            - 영속성(Persistence)이란?
                
                ```markdown
                - 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성
                ```
                
            - 개념
                
                ```markdown
                엔티티를 영구 저장하는 환경
                애플리케이션과 데이터베이스 사이에 객체를 보관하는 가상의 환경
                ```
                
            - 이점
                
                ```markdown
                1. 1차 캐시 : 1차 캐시에서 조회가 가능하며, 없으면 DB에서 조회해서 1차 캐시로 가져온다.
                2. 동일성 보장 : 하나의 트랜잭션 안에서 같은 객체에 대해서 동일성을 보장해준다.
                3. 쓰기 지연 : 트랜잭션 안에서 쿼리의 결과를 모아서 처리한다.
                4. 변경 감지 : 스냅샷을 찍어두고 커밋 시점에 비교해서 update 쿼리 전송해준다.
                5. 지연 로딩 : 쓸데 없는 오버헤딩을 줄이기 위해서 사용, 진짜 사용시점에 쿼리를 날려 정보를 가져온다.
                ```
                
        - N+1 문제
            - 언제 발생?
                
                ```markdown
                한개의 쿼리를 수행하는데 N개의 쿼리가 연쇄적으로 일어날 수 있는 것
                ```
                
            - 어떻게 해결?
                
                ```markdown
                fetch 전략을 lazy
                fetchjoin을 사용
                ```
                
            - fetch 전략
                - eager
                    
                    즉시 로딩
                    
                - lazy
                    
                    지연 로딩
                    
- CI/CD
    
    ```markdown
    지속적 통합 / 지속적 배포
    CI 프로세스를 통해 개발 중에 지속적으로 빌드와 테스트를 진행하고, 이를 통과한 코드에 대하여 테스트 서버와 운영 서버에 곧바로 그 내용을 배포해 반영하는 것
    ```
    
- Docker
    - docker란?
        
        ```markdown
        컨테이너 기반의 가상화 기술
        ```
        
- TCP 3-way Handshake
    
    [https://mindnet.tistory.com/entry/네트워크-쉽게-이해하기-22편-TCP-3-WayHandshake-4-WayHandshake](https://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake)
    
    ```markdown
    본격적으로 통신을 하기 전, Client와 Server가 잘 연결이 되었는지 확인하는 과정
    
    1. Client->Server : TCP SYN 패킷을 서버에 보내 connection 요청
    2. Server->Client : TCP SYN+ACK으로 응답
    3. Client->Server : TCP ACK 패킷을 보냄
    ```
    
- CORS
    
    ```markdown
    Cross-Origin-Resource-Sharing
    도메인이 다른 2개의 사이트가 데이터를 주고 받을 때 발생하는 문제
    서버 내에서 요청이 허락된 도메인에만 데이터를 주기 위해서
    ```
    
- 자료구조 / 알고리즘
    - Map, Set, List
        - Map
            
            ```markdown
            - Key, Value의 한쌍으로 이루어지는 데이터의 집합
            - Key에 대한 중복이 없으며 순서를 보장하지 않음
            - Value 값의 중복은 허용
            - 뛰어난 검색 속도
            - 인덱스가 따로 존재하지 않으므로 iterator 사용
            ```
            
        - Set
            
            ```markdown
            - 데이터의 집합이며 순서가 없고 중복된 데이터를 허용하지 않음
            - 중복되지 않은 데이터를 구할 때 유용
            - 빠른 검색 속도
            - 인덱스가 따로 존재하지 않으므로 iterator 사용
            ```
            
        - List
            
            ```markdown
            - 순서가 있고 중복을 허용
            - 인덱스로 원소에 접근 가능
            - 크기가 가변적
            ```
            
            - ArrayList와 LinkedList 차이
                
                ```markdown
                ArrayList
                - 단방향 포인터 구조로 데이터 순차적 접근에 강점을 가짐
                - 배열 기반으로 데이터 저장
                - 데이터 삽입, 삭제가 느림
                - 데이터 조회가 빠름
                
                LinkedList
                - 양방향 포인터 구조로 삽입, 삭제가 빠르다.
                - 검색은 ArrayList보다 느리다.
                ```
                
    - iterator
        
        ```markdown
        객체 지향적 프로그래밍에서 배열이나 그와 유사한 자료구조의 내부 요소를 순회하는 개체
        ```
        
    - 이진탐색트리
        
        ```markdown
        - 정렬된 이진 트리
        - 노드의 왼쪽 하위 트리에는 노드의 키보다 작은 키가 있는 노드만 포함
        - 노드의 오른쪽 하위 트리에는 노드의 키보다 큰 키가 있는 노드만 포함
        - 왼쪽 및 오른쪽 하위 트리도 각각 이진 검색 트리여야 함
        - 중복된 키를 허용하지 않음
        ```
        
    - 해싱이란?
        
        ```markdown
        키에 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근
        ```
        
    - BFS/DFS ⭐️
        
        ```markdown
        BFS(너비 우선 탐색) : 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법
        - 가까운 거리에 있는 정점들을 차례로 정한 후 꺼낼 수 있는 자료구조인 큐가 필요
        - 큐가 공백 상태가 될 때까지 큐에 들어 있던 것들은 하나씩 빼면서 해당 정점에서 방문가능한 인접 정점을 큐에 넣는 과정을 반복
        
        DFS(깊이 우선 탐색) : 시작 정점에서 한 방향으로 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와 다른 방향으로 다시 탐색을 진행하는 순회 방법
        - 미로 탐색에 사용
        - 아직 방문하지 않은 정점이 있다면 그 정점을 시작으로 하여 탐색을 다시 시작
        - 자기 자신을 다시 호출하는 순환 알고리즘의 형태
        ```
